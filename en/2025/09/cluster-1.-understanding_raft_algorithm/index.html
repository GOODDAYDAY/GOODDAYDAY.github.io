<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>[Cluster] 1. RAFT Algorithm: A Complete Evolution from Single Node to Distributed Consensus - GoodyHao's Blog</title><meta name=Description content="Elegance Never Fades"><meta property="og:url" content="https://gooddayday.github.io/en/2025/09/cluster-1.-understanding_raft_algorithm/"><meta property="og:site_name" content="GoodyHao's Blog"><meta property="og:title" content="[Cluster] 1. RAFT Algorithm: A Complete Evolution from Single Node to Distributed Consensus"><meta property="og:description" content="Introduction RAFT (Raft Consensus Algorithm) is a distributed consensus algorithm designed to solve the problem of achieving data state agreement among multiple nodes in distributed systems. Compared to the renowned Paxos algorithm, RAFT’s design philosophy emphasizes “understandability” through clear role separation and straightforward state transitions, making it easier for developers to comprehend and implement. This article demonstrates the complete evolution of the RAFT algorithm from single-node to multi-node clusters through 11 detailed diagrams, covering key scenarios including normal operation, failure handling, network partitions, and conflict resolution. Core RAFT Concepts Before diving into the analysis, let’s familiarize ourselves with several core concepts of RAFT: Node States:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-26T21:27:17+08:00"><meta property="article:modified_time" content="2025-12-06T22:29:56+08:00"><meta property="article:tag" content="Cluster"><meta property="article:tag" content="RAFT"><meta property="article:tag" content="Distributed"><meta property="article:tag" content="Algorithm"><meta property="og:image" content="https://gooddayday.github.io/logo.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://gooddayday.github.io/logo.jpg"><meta name=twitter:title content="[Cluster] 1. RAFT Algorithm: A Complete Evolution from Single Node to Distributed Consensus"><meta name=twitter:description content="Introduction RAFT (Raft Consensus Algorithm) is a distributed consensus algorithm designed to solve the problem of achieving data state agreement among multiple nodes in distributed systems. Compared to the renowned Paxos algorithm, RAFT’s design philosophy emphasizes “understandability” through clear role separation and straightforward state transitions, making it easier for developers to comprehend and implement. This article demonstrates the complete evolution of the RAFT algorithm from single-node to multi-node clusters through 11 detailed diagrams, covering key scenarios including normal operation, failure handling, network partitions, and conflict resolution. Core RAFT Concepts Before diving into the analysis, let’s familiarize ourselves with several core concepts of RAFT: Node States:"><meta name=application-name content="LoveIt"><meta name=apple-mobile-web-app-title content="LoveIt"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://gooddayday.github.io/en/2025/09/cluster-1.-understanding_raft_algorithm/><link rel=prev href=https://gooddayday.github.io/en/2025/09/github-2.-mybatis-generator-custom-plugins/><link rel=next href=https://gooddayday.github.io/en/2025/09/github-3.-basic-check/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"[Cluster] 1. RAFT Algorithm: A Complete Evolution from Single Node to Distributed Consensus","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/gooddayday.github.io\/en\/2025\/09\/cluster-1.-understanding_raft_algorithm\/"},"image":["https:\/\/gooddayday.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"Cluster, RAFT, Distributed, Algorithm","wordcount":1224,"url":"https:\/\/gooddayday.github.io\/en\/2025\/09\/cluster-1.-understanding_raft_algorithm\/","datePublished":"2025-09-26T21:27:17+08:00","dateModified":"2025-12-06T22:29:56+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/gooddayday.github.io\/images\/logo.jpg"},"author":{"@type":"Person","name":"GoodyHao"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"light"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"light"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/en/ title="GoodyHao's Blog"><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw' aria-hidden=true></i></span>Elegance Never Fades</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/en/posts/>Posts </a><a class=menu-item href=/en/tags/>Tags </a><a class=menu-item href=/en/categories/>Categories </a><a class=menu-item href=/en/categories/documentation/>Docs </a><a class=menu-item href=/en/about/>About </a><a class=menu-item href=https://github.com/GOODDAYDAY/GOODDAYDAY.github.io title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a><a class=menu-item href=/zh-cn/2025/09/cluster-1.-understanding_raft_algorithm/ title=简体中文>中文</a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/en/ title="GoodyHao's Blog"><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw' aria-hidden=true></i></span>Elegance Never Fades</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/en/posts/ title>Posts</a><a class=menu-item href=/en/tags/ title>Tags</a><a class=menu-item href=/en/categories/ title>Categories</a><a class=menu-item href=/en/categories/documentation/ title>Docs</a><a class=menu-item href=/en/about/ title>About</a><a class=menu-item href=https://github.com/GOODDAYDAY/GOODDAYDAY.github.io title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a><a class=menu-item href=/zh-cn/2025/09/cluster-1.-understanding_raft_algorithm/ title=简体中文>中文</a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">[Cluster] 1. RAFT Algorithm: A Complete Evolution from Single Node to Distributed Consensus</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/en/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>GoodyHao</a></span>&nbsp;<span class=post-category>included in <a href=/en/categories/cluster/><i class="far fa-folder fa-fw" aria-hidden=true></i>Cluster</a>&nbsp;<a href=/en/categories/algorithm/><i class="far fa-folder fa-fw" aria-hidden=true></i>Algorithm</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2025-09-26>2025-09-26</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;1224 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;6 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#core-raft-concepts>Core RAFT Concepts</a></li><li><a href=#stage-1-single-node-startup-diagram-1>Stage 1: Single Node Startup (Diagram 1)</a></li><li><a href=#stage-2-handling-client-requests-diagram-2>Stage 2: Handling Client Requests (Diagram 2)</a></li><li><a href=#stage-3-nodes-joining-the-cluster-diagram-3>Stage 3: Nodes Joining the Cluster (Diagram 3)</a></li><li><a href=#stage-4-log-synchronization-diagram-4>Stage 4: Log Synchronization (Diagram 4)</a></li><li><a href=#stage-5-cluster-expansion-diagram-5>Stage 5: Cluster Expansion (Diagram 5)</a></li><li><a href=#stage-6-batch-operations-and-failures-diagram-6--6-result>Stage 6: Batch Operations and Failures (Diagram 6 & 6-Result)</a></li><li><a href=#stage-7-election-failure-scenario-diagram-7>Stage 7: Election Failure Scenario (Diagram 7)</a></li><li><a href=#stage-8-election-within-partition-diagram-8>Stage 8: Election Within Partition (Diagram 8)</a></li><li><a href=#stage-9-new-leader-established-with-existing-partition-diagram-9>Stage 9: New Leader Established with Existing Partition (Diagram 9)</a></li><li><a href=#stage-10-conflict-detection-diagram-10>Stage 10: Conflict Detection (Diagram 10)</a></li><li><a href=#stage-11-partition-healing-and-conflict-resolution-diagram-11>Stage 11: Partition Healing and Conflict Resolution (Diagram 11)</a></li><li><a href=#key-characteristics-analysis-of-raft-algorithm>Key Characteristics Analysis of RAFT Algorithm</a></li><li><a href=#practical-application-considerations>Practical Application Considerations</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></div><div class=content id=content><h2 id=introduction>Introduction</h2><ul><li>RAFT (Raft Consensus Algorithm) is a distributed consensus algorithm designed to solve the problem of achieving data state agreement among multiple nodes in distributed systems.</li><li>Compared to the renowned Paxos algorithm, RAFT&rsquo;s design philosophy emphasizes &ldquo;understandability&rdquo; through clear role separation and straightforward state transitions, making it easier for developers to comprehend and implement.</li><li>This article demonstrates the complete evolution of the RAFT algorithm from single-node to multi-node clusters through 11 detailed diagrams, covering key scenarios including normal operation, failure handling, network partitions, and conflict resolution.</li></ul><h2 id=core-raft-concepts>Core RAFT Concepts</h2><ul><li>Before diving into the analysis, let&rsquo;s familiarize ourselves with several core concepts of RAFT:</li></ul><p><strong>Node States</strong>:</p><ul><li><strong>Leader</strong>: Handles client requests and replicates log entries to other nodes</li><li><strong>Follower</strong>: Passively receives log replication requests from the Leader</li><li><strong>Candidate</strong>: Temporary state during the Leader election process</li></ul><p><strong>Key Data Structures</strong>:</p><ul><li><strong>Log</strong>: Ordered sequence storing operation commands</li><li><strong>Term</strong>: Monotonically increasing logical clock used to detect stale information</li><li><strong>CommitIndex</strong>: Index of the highest log entry known to be committed</li><li><strong>ApplyIndex/LastApplied</strong>: Index of the highest log entry applied to the state machine</li><li><strong>State</strong>: Actual business data state</li></ul><h2 id=stage-1-single-node-startup-diagram-1>Stage 1: Single Node Startup (Diagram 1)</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Node1 starts as Leader with initial state:
</span></span><span class=line><span class=cl>- Log=[] (empty log)
</span></span><span class=line><span class=cl>- Term=0 (initial term)
</span></span><span class=line><span class=cl>- CommitIndex=0, ApplyIndex=0 (no committed/applied entries)
</span></span><span class=line><span class=cl>- State={} (empty state machine)
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/9.%20raft/1.%20single%20node.svg data-srcset="/images/9.%20raft/1.%20single%20node.svg, /images/9.%20raft/1.%20single%20node.svg 1.5x, /images/9.%20raft/1.%20single%20node.svg 2x" data-sizes=auto alt=/images/9.%20raft/1.%20single%20node.svg title="1. single node.svg"></p><p>In a single-node cluster, the node automatically becomes the Leader as it constitutes a &ldquo;majority&rdquo; (1 > 1/2). This illustrates a crucial property of the RAFT algorithm: at most one Leader can exist at any given moment.</p><h2 id=stage-2-handling-client-requests-diagram-2>Stage 2: Handling Client Requests (Diagram 2)</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Client request: x=1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Processing workflow:
</span></span><span class=line><span class=cl>1. Leader appends &#34;x=1&#34; to the log (Log=[x=1])
</span></span><span class=line><span class=cl>2. Updates Term=1 (in some implementations, term updates upon receiving client requests)
</span></span><span class=line><span class=cl>3. Single node commits immediately (CommitIndex=1)
</span></span><span class=line><span class=cl>4. Applies to state machine (ApplyIndex=1, State={x:1})
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/9.%20raft/2.%20add%20value.svg data-srcset="/images/9.%20raft/2.%20add%20value.svg, /images/9.%20raft/2.%20add%20value.svg 1.5x, /images/9.%20raft/2.%20add%20value.svg 2x" data-sizes=auto alt=/images/9.%20raft/2.%20add%20value.svg title="2. add value.svg"></p><p>This demonstrates RAFT&rsquo;s fundamental workflow: log append → replicate → commit → apply. In single-node scenarios, this process completes instantaneously.</p><h2 id=stage-3-nodes-joining-the-cluster-diagram-3>Stage 3: Nodes Joining the Cluster (Diagram 3)</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Node2 and Node3 join as Followers:
</span></span><span class=line><span class=cl>- New nodes&#39; initial state: Term=0, empty log, empty state machine
</span></span><span class=line><span class=cl>- Discover existing Leader through &#34;join&#34; operation
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/9.%20raft/3.%20add%20nodes.svg data-srcset="/images/9.%20raft/3.%20add%20nodes.svg, /images/9.%20raft/3.%20add%20nodes.svg 1.5x, /images/9.%20raft/3.%20add%20nodes.svg 2x" data-sizes=auto alt=/images/9.%20raft/3.%20add%20nodes.svg title="3. add nodes.svg"></p><p>New nodes join in Follower state and require synchronization of historical data from the Leader. This demonstrates RAFT&rsquo;s dynamic membership change capability.</p><h2 id=stage-4-log-synchronization-diagram-4>Stage 4: Log Synchronization (Diagram 4)</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Leader synchronization process:
</span></span><span class=line><span class=cl>1. Node1 sends AppendEntries RPC to Node2 and Node3
</span></span><span class=line><span class=cl>2. Contains historical log entry &#34;x=1&#34;
</span></span><span class=line><span class=cl>3. Followers update their state:
</span></span><span class=line><span class=cl>   - Term=1 (synchronize Leader&#39;s term)
</span></span><span class=line><span class=cl>   - Log=[x=1] (replicate log entry)
</span></span><span class=line><span class=cl>   - CommitIndex=1, ApplyIndex=1 (commit and apply)
</span></span><span class=line><span class=cl>   - State={x:1} (state machine synchronization)
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/9.%20raft/4.%20node%20sync.svg data-srcset="/images/9.%20raft/4.%20node%20sync.svg, /images/9.%20raft/4.%20node%20sync.svg 1.5x, /images/9.%20raft/4.%20node%20sync.svg 2x" data-sizes=auto alt=/images/9.%20raft/4.%20node%20sync.svg title="4. node sync.svg"></p><p>This stage showcases RAFT&rsquo;s core mechanism: <strong>log replication</strong>. The Leader ensures all Followers maintain log consistency with itself.</p><h2 id=stage-5-cluster-expansion-diagram-5>Stage 5: Cluster Expansion (Diagram 5)</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Continue adding Node4 and Node5:
</span></span><span class=line><span class=cl>- New nodes complete joining and synchronization in one step via &#34;join &amp; rpc sync&#34;
</span></span><span class=line><span class=cl>- Eventually forms a 5-node cluster with all nodes in consistent state
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/9.%20raft/5.%20add%20nodes.svg data-srcset="/images/9.%20raft/5.%20add%20nodes.svg, /images/9.%20raft/5.%20add%20nodes.svg 1.5x, /images/9.%20raft/5.%20add%20nodes.svg 2x" data-sizes=auto alt=/images/9.%20raft/5.%20add%20nodes.svg title="5. add nodes.svg"></p><p>Clusters can expand dynamically, with new nodes automatically completing historical data synchronization upon joining.</p><h2 id=stage-6-batch-operations-and-failures-diagram-6--6-result>Stage 6: Batch Operations and Failures (Diagram 6 & 6-Result)</h2><p><strong>Diagram 6 illustrates the problem scenario</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Leader processes multiple client requests:
</span></span><span class=line><span class=cl>- x=2, y=1, y=2, update term
</span></span><span class=line><span class=cl>- Node1 state: Term=2, CommitIndex=4, State={x:2, y:2}
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/9.%20raft/6.%20add%20value%20%26%20update%20term.svg data-srcset="/images/9.%20raft/6.%20add%20value%20%26%20update%20term.svg, /images/9.%20raft/6.%20add%20value%20%26%20update%20term.svg 1.5x, /images/9.%20raft/6.%20add%20value%20%26%20update%20term.svg 2x" data-sizes=auto alt=/images/9.%20raft/6.%20add%20value%20%26%20update%20term.svg title="6. add value & update term.svg"></p><p><strong>Diagram 6-Result shows recovery state</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Leader continues operation:
</span></span><span class=line><span class=cl>- Node1 successfully synchronizes to Node2, Node4, Node5
</span></span><span class=line><span class=cl>- Node3 fails, maintaining old state (x=1)
</span></span><span class=line><span class=cl>- Cluster continues providing service with majority nodes functioning
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/9.%20raft/6.%20add%20value%20%26%20update%20term%20-%20result.svg data-srcset="/images/9.%20raft/6.%20add%20value%20%26%20update%20term%20-%20result.svg, /images/9.%20raft/6.%20add%20value%20%26%20update%20term%20-%20result.svg 1.5x, /images/9.%20raft/6.%20add%20value%20%26%20update%20term%20-%20result.svg 2x" data-sizes=auto alt=/images/9.%20raft/6.%20add%20value%20%26%20update%20term%20-%20result.svg title="6. add value & update term - result.svg"></p><p>This demonstrates RAFT&rsquo;s <strong>fault tolerance</strong>: the cluster continues operating as long as a majority of nodes remain functional.</p><h2 id=stage-7-election-failure-scenario-diagram-7>Stage 7: Election Failure Scenario (Diagram 7)</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Network partition occurs:
</span></span><span class=line><span class=cl>- Node1 becomes isolated (separate partition)
</span></span><span class=line><span class=cl>- Node3 attempts election but fails:
</span></span><span class=line><span class=cl>  - Updates Term=2, becomes Candidate
</span></span><span class=line><span class=cl>  - Cannot obtain majority votes (log too stale)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Partition state:
</span></span><span class=line><span class=cl>- Partition 1: Node1 (isolated old Leader)
</span></span><span class=line><span class=cl>- Partition 2: Node2, Node3, Node4, Node5 (no new Leader)
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/9.%20raft/7.%20vote%20fail.svg data-srcset="/images/9.%20raft/7.%20vote%20fail.svg, /images/9.%20raft/7.%20vote%20fail.svg 1.5x, /images/9.%20raft/7.%20vote%20fail.svg 2x" data-sizes=auto alt=/images/9.%20raft/7.%20vote%20fail.svg title="7. vote fail.svg"></p><p>This illustrates RAFT&rsquo;s <strong>network partition</strong> handling mechanism: nodes with newer logs are more likely to become the new Leader.</p><h2 id=stage-8-election-within-partition-diagram-8>Stage 8: Election Within Partition (Diagram 8)</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Node2 initiates election:
</span></span><span class=line><span class=cl>- Term=3, becomes Candidate
</span></span><span class=line><span class=cl>- Sends RequestVote RPC to Node4, Node5, Node3
</span></span><span class=line><span class=cl>- Even though Node3&#39;s log is behind, it can still vote for Node2
</span></span><span class=line><span class=cl>- Meanwhile, isolated Node1 continues receiving client request &#34;x=9&#34;
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/9.%20raft/8.%20fail%20but%20command.svg data-srcset="/images/9.%20raft/8.%20fail%20but%20command.svg, /images/9.%20raft/8.%20fail%20but%20command.svg 1.5x, /images/9.%20raft/8.%20fail%20but%20command.svg 2x" data-sizes=auto alt=/images/9.%20raft/8.%20fail%20but%20command.svg title="8. fail but command.svg"></p><ul><li>The partitioned old Leader still processes requests, but these operations <strong>will not be committed</strong> due to inability to obtain majority confirmation.</li></ul><h2 id=stage-9-new-leader-established-with-existing-partition-diagram-9>Stage 9: New Leader Established with Existing Partition (Diagram 9)</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Node2 becomes the new Leader:
</span></span><span class=line><span class=cl>- Obtains sufficient votes, Term=3
</span></span><span class=line><span class=cl>- Begins synchronizing to other nodes
</span></span><span class=line><span class=cl>- Node1 and Node3 remain out of sync:
</span></span><span class=line><span class=cl>  - Node1: Has uncommitted &#34;x=9&#34;, Term=2
</span></span><span class=line><span class=cl>  - Node3: Still contains old data, Term=1
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/9.%20raft/10.%20node2%20new%20leader.svg data-srcset="/images/9.%20raft/10.%20node2%20new%20leader.svg, /images/9.%20raft/10.%20node2%20new%20leader.svg 1.5x, /images/9.%20raft/10.%20node2%20new%20leader.svg 2x" data-sizes=auto alt=/images/9.%20raft/10.%20node2%20new%20leader.svg title="10. node2 new leader.svg"></p><p>This proves RAFT&rsquo;s <strong>partition tolerance</strong>: even with some unreachable nodes, the majority can continue functioning normally.</p><h2 id=stage-10-conflict-detection-diagram-10>Stage 10: Conflict Detection (Diagram 10)</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Node2 as the new Leader begins operation:
</span></span><span class=line><span class=cl>- Synchronizes to Node4 and Node5 (successful)
</span></span><span class=line><span class=cl>- Node1 and Node3 recovery
</span></span><span class=line><span class=cl>- Cluster continues running on available majority nodes
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/9.%20raft/9.%20fail%20node%20back.svg data-srcset="/images/9.%20raft/9.%20fail%20node%20back.svg, /images/9.%20raft/9.%20fail%20node%20back.svg 1.5x, /images/9.%20raft/9.%20fail%20node%20back.svg 2x" data-sizes=auto alt=/images/9.%20raft/9.%20fail%20node%20back.svg title="9. fail node back.svg"></p><p>This state demonstrates the <strong>split-brain</strong> problem: the system contains both new and old Leader states.</p><h2 id=stage-11-partition-healing-and-conflict-resolution-diagram-11>Stage 11: Partition Healing and Conflict Resolution (Diagram 11)</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Final state after network partition repair:
</span></span><span class=line><span class=cl>- All nodes reconnect
</span></span><span class=line><span class=cl>- Node2 remains Leader, Term=3
</span></span><span class=line><span class=cl>- Conflict resolution process:
</span></span><span class=line><span class=cl>  1. Node1 discovers higher term, steps down to Follower
</span></span><span class=line><span class=cl>  2. Node1&#39;s uncommitted operation &#34;x=9&#34; is discarded (log truncation)
</span></span><span class=line><span class=cl>  3. Node3 synchronizes to latest state
</span></span><span class=line><span class=cl>  4. All nodes eventually consistent: State={x:2, y:2}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Data loss: x=9 permanently lost as it was never majority-confirmed
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/9.%20raft/11.%20sync%20%26%20abandon.svg data-srcset="/images/9.%20raft/11.%20sync%20%26%20abandon.svg, /images/9.%20raft/11.%20sync%20%26%20abandon.svg 1.5x, /images/9.%20raft/11.%20sync%20%26%20abandon.svg 2x" data-sizes=auto alt=/images/9.%20raft/11.%20sync%20%26%20abandon.svg title="11. sync & abandon.svg"></p><p>This represents the classic <strong>log conflict</strong> resolution scenario in RAFT:</p><ul><li>Higher term Leaders are authoritative</li><li>Operations not confirmed by majority are discarded</li><li>All nodes eventually achieve strong consistency</li></ul><h2 id=key-characteristics-analysis-of-raft-algorithm>Key Characteristics Analysis of RAFT Algorithm</h2><p>Through these 11 diagrams, we can summarize the important characteristics of RAFT:</p><p><strong>1. Strong Consistency</strong></p><ul><li>All nodes eventually reach identical states</li><li>Data reliability ensured through majority commit</li></ul><p><strong>2. Partition Tolerance</strong></p><ul><li>During network partitions, majority partition continues service</li><li>Minority partition cannot handle write operations</li></ul><p><strong>3. Leader Election</strong></p><ul><li>At most one Leader at any given time</li><li>Latest nodes elected through term and log comparison</li></ul><p><strong>4. Log Replication</strong></p><ul><li>Leader replicates logs to all Followers</li><li>Ensures log ordering and consistency</li></ul><p><strong>5. Failure Recovery</strong></p><ul><li>Nodes can automatically synchronize after rejoining from failure</li><li>Conflicting logs are correctly overwritten</li></ul><h2 id=practical-application-considerations>Practical Application Considerations</h2><p><strong>Performance Characteristics</strong>:</p><ul><li>Write operations require majority confirmation, resulting in higher latency</li><li>Read operations can be performed from Leader or Followers</li><li>Network partitions affect availability</li></ul><p><strong>Suitable Use Cases</strong>:</p><ul><li>Configuration management systems (such as etcd)</li><li>Distributed databases (such as TiKV)</li><li>Distributed lock services</li></ul><p><strong>Important Considerations</strong>:</p><ul><li>Odd-numbered node clusters are preferable (avoid split-brain)</li><li>Network quality significantly impacts performance</li><li>Need to consider safety of membership changes</li></ul><h2 id=conclusion>Conclusion</h2><p>The RAFT algorithm elegantly solves distributed consensus problems through clear role separation and simple rules. This article comprehensively demonstrates the progression from single-node to complex failure scenarios through 11 progressive diagrams. Understanding these scenarios is crucial for designing and implementing reliable distributed systems.</p><p>RAFT&rsquo;s success lies in its <strong>understandability</strong>: compared to Paxos&rsquo;s complex proofs, RAFT employs intuitive concepts (terms, elections, log replication) that enable developers to truly comprehend and correctly implement distributed consistency systems.</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2025-12-06&nbsp;<a class=git-hash href=https://github.com/GOODDAYDAY/GOODDAYDAY.github.io/commit/af3d5c9bd409e602f90f3dec7c5441cd7924d96f target=_blank title="commit by haotian(865700600@qq.com) af3d5c9bd409e602f90f3dec7c5441cd7924d96f: Refactor Redis Cluster documentation for clarity and consistency">
<i class="fas fa-hashtag fa-fw" aria-hidden=true></i>af3d5c9</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/en/2025/09/cluster-1.-understanding_raft_algorithm/index.md target=_blank>Read Markdown</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://gooddayday.github.io/en/2025/09/cluster-1.-understanding_raft_algorithm/ data-title="[Cluster] 1. RAFT Algorithm: A Complete Evolution from Single Node to Distributed Consensus" data-hashtags=Cluster,RAFT,Distributed,Algorithm><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://gooddayday.github.io/en/2025/09/cluster-1.-understanding_raft_algorithm/ data-hashtag=Cluster><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Linkedin" data-sharer=linkedin data-url=https://gooddayday.github.io/en/2025/09/cluster-1.-understanding_raft_algorithm/><i class="fab fa-linkedin fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://gooddayday.github.io/en/2025/09/cluster-1.-understanding_raft_algorithm/ data-title="[Cluster] 1. RAFT Algorithm: A Complete Evolution from Single Node to Distributed Consensus"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://gooddayday.github.io/en/2025/09/cluster-1.-understanding_raft_algorithm/ data-title="[Cluster] 1. RAFT Algorithm: A Complete Evolution from Single Node to Distributed Consensus"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://gooddayday.github.io/en/2025/09/cluster-1.-understanding_raft_algorithm/ data-title="[Cluster] 1. RAFT Algorithm: A Complete Evolution from Single Node to Distributed Consensus"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/en/tags/cluster/>Cluster</a>,&nbsp;<a href=/en/tags/raft/>RAFT</a>,&nbsp;<a href=/en/tags/distributed/>Distributed</a>,&nbsp;<a href=/en/tags/algorithm/>Algorithm</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/en/>Home</a></span></section></div><div class=post-nav><a href=/en/2025/09/github-2.-mybatis-generator-custom-plugins/ class=prev rel=prev title="[Github] 2. MyBatis Generator Custom Plugins"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>[Github] 2. MyBatis Generator Custom Plugins</a>
<a href=/en/2025/09/github-3.-basic-check/ class=next rel=next title="[Github] 3. Basic-Check: Validation Framework">[Github] 3. Basic-Check: Validation Framework<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app>Giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><span class=author itemprop=copyrightHolder>&nbsp;<a href=/en/ target=_blank>GoodyHao</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><link rel=stylesheet href=/css/auto-numbering.css><link rel=stylesheet href=/css/svg-fullwidth.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{giscus:{category:"Announcements",categoryId:"DIC_kwDOPtWtCc4CvteQ",darkTheme:"dark",emitMetadata:"0",inputPosition:"bottom",lang:"en",lazyLoading:!1,lightTheme:"light",mapping:"pathname",reactionsEnabled:"1",repo:"GOODDAYDAY/GOODDAYDAY.github.io",repoId:"R_kgDOPtWtCQ"}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"PASDMWALPK",algoliaIndex:"index.en",algoliaSearchKey:"b42948e51daaa93df92381c8e2ac0f93",highlightTag:"em",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>